# object-storage-service

## Схема
![OSS.svg](docs/OSS.svg)

## Описание
*В данной реализации API Service и Metaservice объединены в одно приложение*

На сервер **A** (API Service) по REST присылают файл, его надо разрезать на 6 примерно равных частей и 
сохранить на серверах хранения **Bn** (n ≥ 6).

При REST-запросе на сервер A нужно достать куски с серверов Bn склеить их и отдать файл.

API Service получает информацию о серверах и по их весу определяет где сохранить каждый чанк файла.
Информация о чанках и серверах хранится в БД Metaservice (PostgreSQL)


### Heartbeat
API Service узнает о доступности серверов хранения через механизм Heartbeat. В ответе сервера хранения также возвращают 
доступное место на серверах. Это позволяет присваивать каждому серверу хранения свой вес в зависимости от оставшегося 
свободного места на диске. При загрузке чанка сервер хранения выбирается по самому максимальному/минимальному весу, что 
поволяет заполнять сервера хранения равномерно.

### Сохранение чанков
Так как в данном задании все файлы делятся на 6 чанков, то при большом количестве файлов маленького размера мы можем 
упереться в ограниченное количество индексных дескрипторов (inode). Для решения этой проблемы было решено сохранять 
чанки в файлы-контейнеры. Поэтому каждый сервер хранения имеет свою БД (SQLite), в которой указывается в каком 
файле-контейнере находится искомый чанк и его смещение в данном файле

## Хранение данных
В данной реализации эта проблема никак не решается, однако подразумевается, что для повышения надежности (durability) 
сервиса необходимо обезопасить пользовательские данные от выхода HDD из строя.

Предположим, что годовая частота отказов жестких дисков составляет 1.89% ([ссылка](https://www.backblaze.com/blog/backblaze-drive-stats-for-q3-2024/))

Обычная репликация (3 реплики) в данном случае даст только 5 девяток надежности (99.99932%), что является довольно 
низким показателем.

Использование RAID по типу 60, может частично решить эту проблему, однако появится проблема при дальнейшем расширении.

В данном случае лучше использовать стирающее кодирование (erasure coding), так как оно позволяет достичь большей 
надежности и настроить под себя сетап, для корректировки устоичивости


